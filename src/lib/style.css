/*

A CSS fuz_css theme file like `@fuzdev/fuz_css/theme.css`
is expected to be imported alongside this one
containing the base variable declarations.
By default that's the `'base'` theme's variables,
which is generated from the default values in `@fuzdev/fuz_css/variables.js`.

Some notes:

- acts as a CSS reset and also sets minimal defaults for elements with themable variables
- uses `:where` on all selectors with more specificity than a single tag/class
	to lower specificity so utility classes override them -
	this also means the fuz_css stylesheet is is less likely to
	interfere with the page's styles regardless of where it's imported
- `.unstyled` class opts out of opinionated styling (colors, borders, decorative properties)
	while keeping normalizations (font inheritance, border-collapse) -
	applied to interactive elements (links, buttons, inputs, summary) and decorative containers,
	but not structural elements where styling aids usability (tables) or is semantic (small)
- needs more variables

*/

*,
::before,
::after,
::backdrop {
	box-sizing: border-box;
	border: 0 solid;
	margin: 0;
	padding: 0;
}

:root,
:host {
	color-scheme: light dark; /* overridden by `:root.dark` and `:root.light` added in the `head` */
	background-color: var(--shade_00);
	color: var(--text_color);
	accent-color: var(--color_a_50);
	line-height: var(--line_height_md);
	font-size: 62.5%; /* see `body.font-size`, using `rem` font size units with a base 16px */
	/* @source https://kilianvalkhof.com/2022/css-html/your-css-reset-needs-text-size-adjust-probably/ */
	-moz-text-size-adjust: none;
	-webkit-text-size-adjust: none;
	text-size-adjust: none;
	-webkit-tap-highlight-color: transparent;
}
:root.dark {
	color-scheme: dark;
}
:root.light {
	color-scheme: light;
}

body {
	min-height: 100vh;
	font-size: 1.6rem; /* matched to `font-size: 62.5%` and same value as the default `--font_size_md`, but this one shouldn't vary */
	font-family: var(--font_family_sans);
	tab-size: 2; /* TODO var */
}

::selection {
	background-color: hsl(var(--hue_a) 90% 80% / 40%);
}

::placeholder {
	opacity: 1;
	color: color-mix(in oklab, currentcolor 50%, transparent);
}

::file-selector-button {
	font: inherit;
	cursor: pointer;
}

/*

Keep hidden behavior when `display` is set.
The `!important` makes this `hidden` behavior much higher specificity.
Respects `hidden="until-found"` for find-in-page support.

@source https://github.com/jensimmons/cssremedy

*/
[hidden]:where(:not([hidden='until-found'])) {
	display: none !important;
}

@media (prefers-reduced-motion) {
	:root {
		/* setting to `initial` disables animations but allows for fallbacks (see PendingAnimation)  */
		--duration_6: initial;
		--duration_5: initial;
		--duration_4: initial;
		--duration_3: initial;
		--duration_2: initial;
		--duration_1: initial;
	}
}

:where(a:not(.unstyled)) {
	cursor: pointer;
	/* TODO should the generic be --link_color or --color? */
	--text_color: var(--link_color);
	color: var(--text_color);
	font-weight: 700;
	text-decoration: var(--text_decoration);
	border-radius: var(--border_radius, var(--border_radius_xs3));
	outline: var(--outline_width) var(--outline_style) var(--outline_color);
}
/* TODO should these be customizable with utility classes? */
:where(a:not(.unstyled):hover) {
	text-decoration: var(--text_decoration_hover);
}
:where(a:not(.unstyled):focus) {
	--outline_width: var(--outline_width_focus);
}
:where(a:not(.unstyled):active) {
	--outline_width: var(--outline_width_active);
}
:where(a:not(.unstyled).selected) {
	--text_color: var(--link_color_selected);
	--outline_color: var(--border_color);
	text-decoration: var(--text_decoration_selected);
}
:where(a:not(.unstyled).selected:active) {
	--outline_color: var(--border_color);
}

:where(:is(ul, ol, menu):not(.unstyled)) {
	padding-left: var(--space_xl4);
}
:where(.unstyled:is(ul, ol, menu)) {
	list-style: none;
}

:where(:is(h1, h2, h3, h4, h5, h6, .heading):not(.unstyled)) {
	font-family: var(--font_family_serif);
	font-size: var(--font_size, inherit);
	line-height: var(--line_height_sm);
	text-wrap: balance; /* @see https://developer.mozilla.org/en-US/docs/Web/CSS/text-wrap#balance */
	/* TODO use this pattern elsewhere? provides API to components like `MdnLogo` */
	overflow-wrap: break-word; /* TODO @many is this best? `anywhere` instead? what about adding elsewhere? */
}

:where(h1:not(.unstyled)) {
	--font_size: var(--font_size_xl3);
	font-weight: 300;
	margin-bottom: var(--space_xl5);
	/* TODO strange to omit only this one, but seems to be generally my desired behavior */
	/* margin-top: var(--space_xl7); */
}
:where(h2:not(.unstyled)) {
	--font_size: var(--font_size_xl2);
	font-weight: 400;
	margin-bottom: var(--space_xl4);
	margin-top: var(--space_xl6);
}
:where(h3:not(.unstyled)) {
	--font_size: var(--font_size_xl);
	font-weight: 500;
	margin-bottom: var(--space_xl3);
	margin-top: var(--space_xl5);
}
:where(h4:not(.unstyled)) {
	--font_size: var(--font_size_lg);
	font-weight: 700;
	margin-bottom: var(--space_xl2);
	margin-top: var(--space_xl4);
}
:where(h5:not(.unstyled)) {
	--font_size: var(--font_size_md);
	font-weight: 900;
	margin-bottom: var(--space_xl);
	margin-top: var(--space_xl3);
}
:where(h6:not(.unstyled)) {
	--font_size: var(--font_size_sm);
	font-weight: 600;
	margin-bottom: var(--space_lg);
	margin-top: var(--space_xl2);
	text-transform: uppercase;
}

:where(p) {
	overflow-wrap: break-word; /* TODO @many is this best? `anywhere` instead? what about adding elsewhere? */
}

/*
TODO remove the :last-child here and elsewhere when margin-trim is fully supported,
currently can break based on DOM structure - https://developer.mozilla.org/en-US/docs/Web/CSS/margin-trim
*/
/* TODO other elements */
/* checkboxes and radios are expected to be nested inside a `label`, thus no bottom margin */
:where(
	:is(
			p,
			ul,
			ol,
			menu,
			form,
			fieldset,
			table,
			details,
			textarea,
			select,
			label,
			pre,
			blockquote,
			aside,
			nav
		):not(:last-child):not(.unstyled)
) {
	margin-bottom: var(--space_lg);
}
:where(section:not(:last-child)) {
	margin-bottom: var(--space_xl7);
}

:where(aside:not(.unstyled)) {
	border-left-color: var(--border_color);
	border-left-style: var(--border_style);
	border-left-width: var(--border_width_3);
	border-radius: var(--border_radius, var(--border_radius_xs));
	padding: var(--space_md);
	color: var(--text_color);
	background-color: var(--fg_10);
}

:where(blockquote:not(.unstyled)) {
	border-left-color: var(--border_color);
	border-left-style: var(--border_style);
	border-left-width: var(--border_width_8);
	padding: var(--space_md);
	color: var(--text_color);
	background-color: var(--fg_10);
}

:where(code:not(.unstyled)) {
	white-space: pre-wrap;
	font-family: var(--font_family_mono);
	-webkit-hyphens: none;
	hyphens: none;
	color: var(--text_color);
	background-color: var(--fg_10);
	padding: 0 var(--space_xs2);
	border-radius: var(--border_radius, var(--border_radius_xs));
}

:where(code.inline, p code) {
	display: inline-block;
	vertical-align: baseline;
}

:where(pre:not(.unstyled)) {
	font-family: var(--font_family_mono);
	color: var(--text_color);
	white-space: pre;
	overflow: auto;
	max-width: 100%;
}

:where(hr:not(.unstyled)) {
	border-top: 1px solid var(--border_color_30);
	border-bottom: 2px solid var(--border_color_30);
	border-left: none;
	border-right: none;
	width: 100%;
	height: 5px;
	margin: var(--space_xl7) 0;
}

:where(fieldset:not(.unstyled)) {
	display: flex;
	flex-direction: column;
}
:where(fieldset) {
	/* TODO consider a global border reset */
	border: 0;
}

:where(legend:not(.unstyled)) {
	font-size: var(--font_size_lg);
	margin-bottom: var(--space_lg);
}

/* normalization - keep font inheritance even for unstyled */
:where(input, textarea, select) {
	font: inherit;
}

:where(:is(input, textarea, select):not(.unstyled)) {
	appearance: none;
	line-height: normal;
	display: block;
	color: var(--text_color);
	background-color: var(--input_fill);
	border-color: var(--border_color);
	border-style: var(--border_style);
	border-width: var(--border_width);
	border-radius: var(--border_radius, var(--border_radius_sm));
	/* TODO --outline_color should default to --hue when available, but can't be set above */
	outline: var(--outline_width) var(--outline_style) var(--outline_color);
	padding: var(--input_padding_y) var(--input_padding_x);
	width: 100%;
	min-width: var(--input_width_min);
	min-height: var(--input_height);
}

:where(textarea:not(.unstyled)) {
	--input_padding_y: var(--space_sm);
	height: 100px;
	resize: vertical;
}

:where(:is(select, option, input[type='color']):not(:disabled)) {
	cursor: pointer;
}

:where(option:not(.unstyled)) {
	color: var(--text_color);
	background-color: var(--shade_00);
}

:where(:is(input, textarea, select):not(.unstyled):hover) {
	--border_color: var(--border_color_20);
}

/* these have no active states because they feel buggy in the browsers,
because the active state only applies when the thumb is clicked directly,
but not for the identical user action of clicking the track,
so for consistent visuals we opt to include no active state */
:where(input[type='checkbox']:not(.unstyled)) {
	cursor: pointer;
	width: var(--input_height_sm);
	height: var(--input_height_sm);
	min-width: var(--input_height_sm);
	min-height: var(--input_height_sm);
	--border_radius: var(--border_radius_xs);
	--input_padding_x: 0;
	--checkbox_content: var(--checkbox_content_empty, '');
}
:where(input[type='checkbox']:not(.unstyled):checked) {
	--checkbox_content: var(--checkbox_content_checked, '✓'); /* ✔✓ ✗ ✘ */
}
:where(input[type='checkbox']:not(.unstyled))::before {
	content: var(--checkbox_content);
	position: relative;
	left: var(--left);
	top: var(--top);
	width: 100%;
	height: 100%;
	text-align: center;
	line-height: normal;
	display: flex;
	align-items: center;
	justify-content: center;
	overflow: var(--overflow, visible);
	font-size: var(--font_size, var(--font_size_xl3));
	color: var(--text_color);
}

:where(input[type='radio']:not(.unstyled)) {
	cursor: pointer;
	width: var(--input_height_sm);
	height: var(--input_height_sm);
	border-radius: 50%;
	min-width: var(--input_height_sm);
	min-height: var(--input_height_sm);
	--input_padding_x: 0;
}
:where(input[type='radio']:not(.unstyled):checked)::before {
	content: '';
	display: block;
	position: relative;
	top: 25%;
	left: 25%;
	width: 50%;
	height: 50%;
	background-color: var(--text_color);
	border-radius: 50%;
}

/* TODO @many figure these variables out so they're easily customized (similar pattern in a lot of places) */
:where(input[type='range']:not(.unstyled)) {
	--thumb_size: var(--space_xl);
	--thumb_background_color: var(--text_70);
	cursor: pointer;
}
:where(input[type='range']:not(.unstyled):hover:not(:disabled)) {
	--thumb_background_color: var(--color_a_50);
}
:where(input[type='range']:not(.unstyled):disabled:active) {
	--thumb_background_color: var(--color_c_50);
}
:where(input[type='range']:not(.unstyled))::-webkit-slider-thumb {
	appearance: none;
	height: var(--thumb_size);
	width: var(--thumb_size);
	border-radius: 50%;
	background-color: var(--thumb_background_color);
	border: 0;
	/*

	this is the only line that differs between the `moz` one
	CSS stops parsing if it hits an unknown selector like `::-moz-range-thumb` in Webkit/Blink,
	so we need both declarations anyway, and the declarations can't be combined with plain CSS,
	one of the few times I've wanted to reach for PostCSS

	*/
	margin-top: calc(var(--thumb_size) / -2);
}
:where(input[type='range']:not(.unstyled))::-moz-range-thumb {
	appearance: none;
	height: var(--thumb_size);
	width: var(--thumb_size);
	border-radius: 50%;
	background-color: var(--thumb_background_color);
	border: 0;
}
:where(input[type='range']:not(.unstyled))::-webkit-slider-runnable-track {
	width: 100%;
	height: var(--border_width);
	background-color: var(--thumb_background_color);
}
:where(input[type='range']:not(.unstyled))::-moz-range-track {
	width: 100%;
	height: var(--border_width);
	background-color: var(--thumb_background_color);
}

/*  TODO :has selector? `button:has(input[type='checkbox']:checked)`
see https://caniuse.com/css-has
 */
:where(input:not(.unstyled):checked:not(:disabled)) {
	--text_color: var(--color_a_50);
	--border_color: var(--color_a_50);
}
:where(input[type='radio']:not(.unstyled):checked) {
	cursor: default;
}

:where(
	:is(input, textarea, select):not(.unstyled).inline,
	p :is(input, textarea, select):not(.unstyled)
) {
	display: inline-block;
	margin-left: var(--space_lg);
	/* TODO ideally `width` here would be set to a minimum and have an API to increase size --
	buttons can grow automatically, but how can inputs? only with js?
	 */
	width: var(--input_width_min);
}

:where(:is(input, textarea, select):not(.unstyled):disabled) {
	/* TODO ideally these would just set `fill`, but they'd have to go after the button variants, and then duplicate selectors? */
	--input_fill: transparent;
	--border_style: solid dashed;
	opacity: var(--disabled_opacity);
	outline: none;
}

:where([contenteditable]:not(.unstyled):focus-visible) {
	--outline_width: var(--outline_width_focus);
	outline: var(--outline_width) var(--outline_style) var(--outline_color);
}
:where(:is(input, textarea, select, [contenteditable]):not(.unstyled):active) {
	--outline_width: var(--outline_width_active);
}

/* TODO could improve this with the coming `:has` selector
for disabled colors without needing a wrapper .disabled class */
:where(label:not(.unstyled)) {
	color: var(--text_color);
	cursor: pointer;
}
:where(:is(label:not(.unstyled) .title)) {
	font-weight: 600;
	margin-bottom: var(--space_xs2);
}
:where(label.selected:not(.unstyled)) {
	cursor: default;
	--text_color: var(--color_a_50);
}
:where(label.disabled:not(.unstyled)) {
	cursor: default;
	--text_color: var(--text_disabled);
}
:where(label.row:not(.unstyled)) {
	justify-content: flex-start;
}
:where(label.row:not(.unstyled) :is(input[type='checkbox'], input[type='radio']):not(.unstyled)) {
	margin-right: var(--space_md);
}

/*

TODO think through these patterns to get somewhere consistent

- declaring variables with variants like `_hover` enables simpler theming, so you don't have to write complex selectors and can just change a variable
- should the variants therefore be changed to style variables or inlined here?
- inlining them here avoids the overhead of variables, but is that optimizable anyway? are there added costs in theory that aren't avoidable?
- but these need to be resolved locally to get overrides, couldn't set `fill` for example - can you use a variable still though, just also locally declare it?

*/
:where(button:not(.unstyled)) {
	--min_height: var(--input_height);
	--text_color: var(--text_70);
	--button_text_color: var(--text_color);
	--button_fill: color-mix(in hsl, var(--fill, var(--shade_50)) 8%, transparent);
	--button_fill_hover: color-mix(in hsl, var(--fill, var(--shade_50)) 16%, transparent);
	--button_fill_active: color-mix(in hsl, var(--fill, var(--shade_50)) 24%, transparent);
	--button_border_color: var(--border_color);
	/* TODO give real values, 90%? */
	--button_border_color_hover: color-mix(in hsl, var(--border_color) 90%, var(--shade_max));
	--button_border_color_active: color-mix(in hsl, var(--border_color) 80%, var(--shade_max));
	color: var(--button_text_color);
	background-color: var(--button_fill);
	cursor: pointer;
	appearance: none;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	justify-content: center;
	font: inherit;
	font-size: var(--font_size, inherit);
	font-weight: 700;
	line-height: normal;
	min-height: var(--min_height);
	padding: 0 var(--input_padding_x);
	box-shadow: var(--shadow, var(--button_shadow));
	border-width: var(--border_width);
	border-style: var(--border_style);
	border-color: var(--button_border_color);
	border-radius: var(--border_radius, var(--border_radius_sm));
	outline: var(--outline_width) var(--outline_style) var(--outline_color);
}

:where(:is(button, input, textarea, select):not(.unstyled):focus) {
	--border_color: var(--color_a_50);
	--outline_width: var(--outline_width_focus);
}

/* TODO maybe gradients? or at least use a text_color */
/* TODO hover variants with brighter borders? maybe use a colorless border for that? */

:where(button:not(.unstyled).color_a) {
	--text_color: var(--color_a_50);
	--fill: var(--color_a_40);
	--border_color: var(--color_a_50);
	--outline_color: var(--color_a_50);
}
:where(button:not(.unstyled).color_b) {
	--text_color: var(--color_b_50);
	--fill: var(--color_b_40);
	--border_color: var(--color_b_50);
	--outline_color: var(--color_b_50);
}
:where(button:not(.unstyled).color_c) {
	--text_color: var(--color_c_50);
	--fill: var(--color_c_40);
	--border_color: var(--color_c_50);
	--outline_color: var(--color_c_50);
}
:where(button:not(.unstyled).color_d) {
	--text_color: var(--color_d_50);
	--fill: var(--color_d_40);
	--border_color: var(--color_d_50);
	--outline_color: var(--color_d_50);
}
:where(button:not(.unstyled).color_e) {
	--text_color: var(--color_e_50);
	--fill: var(--color_e_40);
	--border_color: var(--color_e_50);
	--outline_color: var(--color_e_50);
}
:where(button:not(.unstyled).color_f) {
	--text_color: var(--color_f_50);
	--fill: var(--color_f_40);
	--border_color: var(--color_f_50);
	--outline_color: var(--color_f_50);
}
:where(button:not(.unstyled).color_g) {
	--text_color: var(--color_g_50);
	--fill: var(--color_g_40);
	--border_color: var(--color_g_50);
	--outline_color: var(--color_g_50);
}
:where(button:not(.unstyled).color_h) {
	--text_color: var(--color_h_50);
	--fill: var(--color_h_40);
	--border_color: var(--color_h_50);
	--outline_color: var(--color_h_50);
}
:where(button:not(.unstyled).color_i) {
	--text_color: var(--color_i_50);
	--fill: var(--color_i_40);
	--border_color: var(--color_i_50);
	--outline_color: var(--color_i_50);
}
:where(button:not(.unstyled).color_j) {
	--text_color: var(--color_j_50);
	--fill: var(--color_j_40);
	--border_color: var(--color_j_50);
	--outline_color: var(--color_j_50);
}

/* TODO try to rearrange some of this to go after the colored variants */
:where(button:not(.unstyled):disabled) {
	/* TODO ideally these would just set `fill`, but they'd have to go after the button variants, and then duplicate selectors? */
	--button_fill: transparent;
	--border_style: solid dashed;
	cursor: default;
	box-shadow: none;
	opacity: var(--disabled_opacity);
	outline: none;
}
:where(button:not(.unstyled).selected) {
	--button_text_color: var(--text_10);
	--button_fill: var(--fill, var(--shade_50));
	--button_fill_hover: var(--fill, var(--shade_50));
	--button_fill_active: var(--fill, var(--shade_50));
	--button_border_color: var(--border_color);
}
:where(button:not(.unstyled).selected:not(.deselectable)) {
	--button_border_color_hover: var(--border_color);
	--button_border_color_active: var(--border_color);
	cursor: default;
	box-shadow: none;
}
:where(button:not(.unstyled):not(:disabled):hover, button:not(.unstyled):focus) {
	--button_fill: var(--button_fill_hover);
	--button_border_color: var(--button_border_color_hover);
	--shadow: var(--button_shadow_hover);
}
:where(button:not(.unstyled):not(.selected):not(:disabled):hover) {
	/* TODO or set a hover var? make consistent with fill */
	--button_border_color: var(--button_border_color_hover);
	--button_text_color: color-mix(in hsl, var(--text_color) 90%, var(--shade_max));
}
:where(button:not(.unstyled).selected.deselectable:not(:disabled):hover) {
	--button_text_color: var(--shade_min);
}
:where(button:not(.unstyled):not(:disabled):active) {
	--button_fill: var(--button_fill_active);
	--button_border_color: var(--button_border_color_active);
	--outline_width: var(--outline_width_active);
	--shadow: var(--button_shadow_active);
}
:where(
	:is(input, textarea, select, button):not(.unstyled):disabled:active,
	label:not(.unstyled).disabled:active
) {
	--text_color: var(--color_c_50);
	--border_color: var(--color_c_50);
}
/* TODO is there a cleaner way to override these through vars? */
:where(button:not(.unstyled).selected:disabled:active) {
	--text_color: var(--text_10);
	--fill: var(--color_c_40);
}
:where(button:not(.unstyled):not(.selected):disabled:active) {
	--fill: transparent;
}
:where(button:not(.unstyled).selected:not(.deselectable):active) {
	--outline_width: var(--outline_width_focus);
}

:where(button:not(.unstyled).inline, p button:not(.unstyled)) {
	display: inline-block;
	--min_height: var(--input_height_sm); /* TODO this increases paragraph line spacing */
}

:where(small) {
	font-size: var(--font_size_sm);
}

:where(img, picture, canvas, svg, video) {
	display: block;
	max-width: 100%; /* shrink to fit */
	height: auto; /* preserve aspect ratio */
}

:where(audio) {
	width: 100%;
}

:where(summary:not(.unstyled)) {
	cursor: pointer;
	padding: var(--space_md);
	border-radius: var(--border_radius, var(--border_radius_xs));
}
:where(summary:hover:not(.unstyled)) {
	background-color: var(--fg_05);
}
:where(summary:active:not(.unstyled)) {
	background-color: var(--fg_20);
}
:where(details[open] summary:not(.unstyled)) {
	margin-bottom: var(--space_sm);
}

:where(table) {
	border-collapse: collapse;
}
:where(thead) {
	text-align: left;
}
:where(th) {
	font-weight: bold;
}
:where(th, td) {
	padding: var(--space_xs3) var(--space_sm);
}
:where(tr) {
	border-bottom: 1px solid var(--border_color_10);
}
:where(tr:hover) {
	background-color: var(--fg_05);
}

:where(abbr[title]) {
	text-decoration: underline dotted;
}

:where(b, strong) {
	font-weight: bolder;
}

:where(kbd, samp) {
	font-family: var(--font_family_mono);
}

:where(sub, sup) {
	font-size: 75%;
	line-height: 0;
	position: relative;
	vertical-align: baseline;
}
:where(sub) {
	bottom: -0.25em;
}
:where(sup) {
	top: -0.5em;
}

:where(progress) {
	vertical-align: baseline;
}
