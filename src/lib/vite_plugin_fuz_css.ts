/**
 * Vite plugin for fuz_css utility class generation.
 *
 * Uses Vite's transform hook to extract CSS classes from source files
 * as they're processed, including node_modules dependencies.
 * Generates CSS on-demand via virtual module with HMR support.
 *
 * @example
 * ```ts
 * // vite.config.ts
 * import {defineConfig} from 'vite';
 * import jsx from 'acorn-jsx';
 * import {vite_plugin_fuz_css} from '@fuzdev/fuz_css/vite_plugin_fuz_css.js';
 *
 * export default defineConfig({
 *   plugins: [
 *     vite_plugin_fuz_css({
 *       acorn_plugins: [jsx()],
 *     }),
 *   ],
 * });
 * ```
 *
 * @module
 */

import type {Plugin, ViteDevServer} from 'vite';
import {join} from 'node:path';

import {extract_css_classes_with_locations, type AcornPlugin} from './css_class_extractor.js';
import {type Diagnostic, CssGenerationError} from './diagnostics.js';
import {
	generate_classes_css,
	type CssClassDefinition,
	type CssClassDefinitionInterpreter,
} from './css_class_generation.js';
import {css_class_definitions} from './css_class_definitions.js';
import {css_class_interpreters} from './css_class_interpreters.js';
import {load_css_properties} from './css_literal.js';
import {
	DEFAULT_CACHE_DIR,
	get_cache_path,
	load_cached_extraction,
	save_cached_extraction,
	delete_cached_extraction,
	from_cached_extraction,
	compute_hash,
} from './css_cache.js';
import {type FileFilter, filter_file_default} from './file_filter.js';
import {CssClasses} from './css_classes.js';
import {type StyleRuleIndex, load_style_rule_index} from './style_rule_parser.js';
import {type VariableDependencyGraph, build_default_variable_graph} from './variable_graph.js';
import {type ClassVariableIndex, get_default_class_variable_index} from './class_variable_index.js';
import {resolve_css, generate_unified_css} from './css_unified_resolution.js';

/* eslint-disable no-console */

/** Marker comment used to delimit generated CSS in the output. */
export const FUZ_CSS_MARKER = '/* generated by vite_plugin_fuz_css */';

const VIRTUAL_ID = 'virtual:fuz.css';
// In dev mode, resolve to .js so Vite treats it as JS (for HMR handling)
// In build mode, resolve to .css for proper CSS bundling
const RESOLVED_VIRTUAL_ID_JS = '\0virtual:fuz.css.js';
const RESOLVED_VIRTUAL_ID_CSS = '\0virtual:fuz.css';

// TODO investigate: Dev mode uses a JS wrapper that injects CSS and self-accepts HMR.
// We couldn't get plain CSS with `css-update` to work for virtual modules - there's a
// mismatch between `data-vite-dev-id` (set to `\0virtual:fuz.css`) and the importable
// URL (`/@id/__x00__virtual:fuz.css`). UnoCSS uses `js-update` with `mod.url` for plain
// CSS but that broke all HMR when we tried it. Areas to investigate:
// - How does Vite's CSS HMR actually resolve virtual module URLs?
// - Why does UnoCSS's approach work for them but not here?
// - Is there a way to control what `data-vite-dev-id` gets set to?
// The current JS wrapper approach works reliably, but plain CSS would be cleaner.

/**
 * Skip cache on CI (no point writing cache that won't be reused).
 */
const is_ci = !!process.env.CI;

/**
 * Options for the fuz_css Vite plugin.
 */
export interface VitePluginFuzCssOptions {
	/**
	 * Filter function to determine which files to extract classes from.
	 * By default, extracts from .svelte, .html, .ts, .js, .tsx, .jsx files,
	 * excluding test files and .gen files.
	 */
	filter_file?: FileFilter;
	/**
	 * Additional class definitions to merge with defaults.
	 * User definitions take precedence over defaults with the same name.
	 * Required when `include_default_definitions` is `false`.
	 */
	class_definitions?: Record<string, CssClassDefinition | undefined>;
	/**
	 * Whether to include default class definitions (token and composite classes).
	 * When `false`, `class_definitions` is required.
	 * @default true
	 */
	include_default_definitions?: boolean;
	/**
	 * Custom interpreters for dynamic class generation.
	 * Replaces the builtin interpreters entirely if provided.
	 */
	class_interpreters?: Array<CssClassDefinitionInterpreter>;
	/**
	 * Classes to always include in the output, regardless of detection.
	 */
	include_classes?: Iterable<string>;
	/**
	 * Classes to exclude from the output, even if detected.
	 */
	exclude_classes?: Iterable<string>;
	/**
	 * Additional acorn plugins for parsing.
	 * Use `acorn-jsx` for React/Preact/Solid projects.
	 */
	acorn_plugins?: Array<AcornPlugin>;
	/**
	 * How to handle CSS-literal errors during generation.
	 * - 'log': Log errors, skip invalid classes, continue
	 * - 'throw': Throw on first error, fail the build
	 * @default 'throw' in CI, 'log' otherwise
	 */
	on_error?: 'log' | 'throw';
	/**
	 * How to handle warnings during generation.
	 * - 'log': Log warnings, continue
	 * - 'throw': Throw on first warning, fail the build
	 * - 'ignore': Suppress warnings entirely
	 * @default 'log'
	 */
	on_warning?: 'log' | 'throw' | 'ignore';
	/**
	 * Cache directory relative to project root.
	 * @default DEFAULT_CACHE_DIR
	 */
	cache_dir?: string;
	/**
	 * Whether to include base styles from style.css.
	 * When enabled, only styles for detected elements are included.
	 * @default true
	 */
	include_base_styles?: boolean;
	/**
	 * Whether to include theme variables from the variable graph.
	 * When enabled, only variables needed by base styles and utility classes are included.
	 * @default true
	 */
	include_theme_styles?: boolean;
	/**
	 * Specificity multiplier for theme CSS selectors.
	 * Value of 1 generates `:root`, higher values generate more specific selectors (e.g., `:root:root`).
	 * @default 1
	 */
	theme_specificity?: number;
	/**
	 * Additional HTML elements to always include styles for.
	 * Useful for elements generated at runtime.
	 */
	include_elements?: Iterable<string>;
	/**
	 * Additional CSS variables to always include in theme output.
	 * Useful for variables referenced dynamically.
	 */
	include_variables?: Iterable<string>;
	/**
	 * Include all theme variables regardless of detection.
	 * Useful for debugging or when many variables are used dynamically.
	 * @default false
	 */
	include_all_variables?: boolean;
}

/**
 * Creates the fuz_css Vite plugin.
 *
 * Extracts CSS classes from source files during Vite's transform phase
 * and generates optimized CSS via the `virtual:fuz.css` virtual module.
 */
export const vite_plugin_fuz_css = (options: VitePluginFuzCssOptions = {}): Plugin => {
	const {
		filter_file = filter_file_default,
		class_definitions: user_class_definitions,
		include_default_definitions = true,
		class_interpreters = css_class_interpreters,
		include_classes,
		exclude_classes,
		acorn_plugins,
		on_error = is_ci ? 'throw' : 'log',
		on_warning = 'log',
		cache_dir = DEFAULT_CACHE_DIR,
		include_base_styles = true,
		include_theme_styles = true,
		theme_specificity = 1,
		include_elements,
		include_variables,
		include_all_variables,
	} = options;

	// Merge class definitions (user definitions take precedence)
	if (!include_default_definitions && !user_class_definitions) {
		throw new Error('class_definitions is required when include_default_definitions is false');
	}
	const all_class_definitions = include_default_definitions
		? user_class_definitions
			? {...css_class_definitions, ...user_class_definitions}
			: css_class_definitions
		: user_class_definitions!;

	// Convert to Sets for efficient lookup
	const include_set = include_classes ? new Set(include_classes) : null;
	const exclude_set = exclude_classes ? new Set(exclude_classes) : null;

	// Plugin state
	const css_classes = new CssClasses(include_set, exclude_set);
	const hashes: Map<string, string> = new Map();
	let virtual_module_loaded = false;
	let server: ViteDevServer | null = null;
	let css_properties: Set<string> | null = null;
	let resolved_cache_dir: string | null = null;
	let project_root: string | null = null;
	let hmr_timeout: ReturnType<typeof setTimeout> | null = null;
	let last_generated_css: string | null = null;

	// Unified CSS resources (loaded eagerly in buildStart when unified mode is enabled)
	let style_rule_index: StyleRuleIndex | null = null;
	let variable_graph: VariableDependencyGraph | null = null;
	let class_variable_index: ClassVariableIndex | null = null;

	/** Logs a warning message (works in both dev and build) */
	const log_warn = (msg: string): void => {
		if (server) {
			server.config.logger.warn(msg);
		} else {
			console.warn(msg);
		}
	};

	/** Logs an error message (works in both dev and build) */
	const log_error = (msg: string): void => {
		if (server) {
			server.config.logger.error(msg);
		} else {
			console.error(msg);
		}
	};

	/**
	 * Computes cache path for a file.
	 * Internal files use relative paths, external files use hashed absolute paths.
	 */
	const get_file_cache_path = async (file_id: string): Promise<string> => {
		const is_internal = file_id.startsWith(project_root!);
		return is_internal
			? get_cache_path(file_id, resolved_cache_dir!, project_root!)
			: join(
					resolved_cache_dir!,
					'_external',
					(await compute_hash(file_id)).slice(0, 16) + '.json',
				);
	};

	/**
	 * Generates CSS from the current classes.
	 */
	const generate_css = (): string => {
		const {
			all_classes: classes,
			all_classes_with_locations: locations,
			explicit_classes,
			all_elements,
			all_css_variables,
		} = css_classes.get_all();

		const utility_result = generate_classes_css({
			class_names: classes,
			class_definitions: all_class_definitions,
			interpreters: class_interpreters,
			css_properties,
			class_locations: locations,
			explicit_classes,
		});

		// Collect all diagnostics: extraction + generation
		const all_diagnostics: Array<Diagnostic> = [
			...css_classes.get_diagnostics(),
			...utility_result.diagnostics,
		];

		// Generate unified CSS if base or theme styles are enabled and resources are loaded
		let final_css: string;
		if (
			(include_base_styles || include_theme_styles) &&
			style_rule_index &&
			variable_graph &&
			class_variable_index
		) {
			const resolution = resolve_css({
				style_rule_index,
				variable_graph,
				class_variable_index,
				detected_elements: all_elements,
				detected_classes: classes,
				detected_css_variables: all_css_variables,
				utility_variables_used: utility_result.variables_used,
				include_elements,
				include_variables,
				include_all_variables,
				theme_specificity,
			});

			// Add resolution diagnostics
			all_diagnostics.push(...resolution.diagnostics);

			final_css = generate_unified_css(resolution, utility_result.css, {
				include_theme: include_theme_styles,
				include_base: include_base_styles,
				include_utilities: true,
			});
		} else {
			// Utility-only mode (legacy behavior or resources not loaded yet)
			final_css = utility_result.css;
		}

		// Separate errors and warnings
		const errors = all_diagnostics.filter((d) => d.level === 'error');
		const warnings = all_diagnostics.filter((d) => d.level === 'warning');

		// Handle warnings based on on_warning setting
		if (warnings.length > 0) {
			if (on_warning === 'throw') {
				throw new CssGenerationError(warnings);
			} else if (on_warning === 'log') {
				for (const d of utility_result.diagnostics.filter((d) => d.level === 'warning')) {
					log_warn(`[fuz_css] ${d.class_name}: ${d.message}`);
				}
			}
			// 'ignore' - do nothing
		}

		// Handle errors based on on_error setting
		if (errors.length > 0) {
			if (on_error === 'throw') {
				throw new CssGenerationError(errors);
			}
			// Log errors (extraction diagnostics already logged in transform)
			for (const d of utility_result.diagnostics.filter((d) => d.level === 'error')) {
				log_error(`[fuz_css] ${d.class_name}: ${d.message}`);
			}
		}

		return `${FUZ_CSS_MARKER}\n\n${final_css}\n\n${FUZ_CSS_MARKER}`;
	};

	/**
	 * Invalidates the virtual module and triggers HMR.
	 * Debounced to avoid spamming updates when multiple files change rapidly.
	 * Only triggers if the generated CSS actually changed.
	 */
	const invalidate_virtual_module = (): void => {
		if (!server) return;

		// Debounce: wait 10ms for more changes before triggering HMR
		if (hmr_timeout) {
			clearTimeout(hmr_timeout);
		}
		hmr_timeout = setTimeout(() => {
			hmr_timeout = null;

			// Check if CSS actually changed
			const new_css = generate_css();
			if (new_css === last_generated_css) {
				return; // No change, skip HMR
			}
			last_generated_css = new_css;

			const mod = server!.moduleGraph.getModuleById(RESOLVED_VIRTUAL_ID_JS);
			if (mod) {
				server!.moduleGraph.invalidateModule(mod);
				// TODO investigate: This hardcoded path matches Vite's URL encoding for virtual
				// modules. Using `mod.url` doesn't work (it's `\0virtual:fuz.css.js`). Could break
				// if Vite changes their encoding scheme. Is there a proper API for this?
				const hmr_path = '/@id/__x00__virtual:fuz.css.js';
				const hot = server?.hot ?? server!.ws;
				hot.send({
					type: 'update',
					updates: [
						{
							type: 'js-update',
							path: hmr_path,
							acceptedPath: hmr_path,
							timestamp: Date.now(),
						},
					],
				});
			}
		}, 10);
	};

	return {
		name: 'vite-plugin-fuz-css',
		// Run before other plugins (like Svelte) to see original source files
		enforce: 'pre',

		configResolved(resolved_config) {
			const root = resolved_config.root;
			project_root = root.endsWith('/') ? root : root + '/';
			resolved_cache_dir = join(root, cache_dir);
		},

		configureServer(dev_server) {
			server = dev_server;

			// Handle file deletion - watcher 'unlink' event
			dev_server.watcher.on('unlink', (file) => {
				if (hashes.has(file)) {
					css_classes.delete(file);
					hashes.delete(file);

					// Delete cache file (fire and forget)
					if (!is_ci && resolved_cache_dir && project_root) {
						get_file_cache_path(file)
							.then((cache_path) => delete_cached_extraction(cache_path))
							.catch(() => {
								// Ignore cache deletion errors
							});
					}

					if (virtual_module_loaded) {
						invalidate_virtual_module();
					}
				}
			});
		},

		async buildStart() {
			// Load CSS properties for validation
			css_properties = await load_css_properties();

			// Load unified CSS resources if unified mode is enabled
			if (include_base_styles || include_theme_styles) {
				style_rule_index = await load_style_rule_index();
				variable_graph = build_default_variable_graph();
				class_variable_index = get_default_class_variable_index();
			}
		},

		resolveId(id) {
			if (id === VIRTUAL_ID) {
				// In dev mode, resolve to .js for HMR support
				// In build mode, resolve to .css for proper bundling
				return server ? RESOLVED_VIRTUAL_ID_JS : RESOLVED_VIRTUAL_ID_CSS;
			}
			return undefined;
		},

		load(id) {
			// Dev mode: JS module that injects CSS and handles HMR
			if (id === RESOLVED_VIRTUAL_ID_JS) {
				virtual_module_loaded = true;
				const css = generate_css();
				last_generated_css = css; // Track for HMR diffing
				const escaped_css = JSON.stringify(css);
				return `
const css = ${escaped_css};

// Find existing style tag or create new one
let style = document.querySelector('style[data-fuz-css]');
if (!style) {
  style = document.createElement('style');
  style.setAttribute('data-fuz-css', '');
  document.head.appendChild(style);
}
style.textContent = css;

if (import.meta.hot) {
  import.meta.hot.accept();
}

export {};
`;
			}
			// Build mode: plain CSS
			if (id === RESOLVED_VIRTUAL_ID_CSS) {
				virtual_module_loaded = true;
				// Return empty CSS for build - generateBundle will append the complete CSS
				return '/* fuz_css placeholder */';
			}
			return undefined;
		},

		generateBundle(_options, bundle) {
			// Regenerate CSS with all extracted classes and append to the CSS asset
			// This runs after all transforms are complete, so all classes are available
			const generated_css = generate_css();

			// Find the main CSS asset and append our generated CSS
			// Vite combines all CSS into one or more asset files
			for (const chunk of Object.values(bundle)) {
				if (
					chunk.type === 'asset' &&
					typeof chunk.source === 'string' &&
					chunk.fileName.endsWith('.css')
				) {
					// Append the complete generated CSS to the end
					chunk.source = chunk.source + '\n' + generated_css;
					break; // Only append to first CSS asset
				}
			}
		},

		async transform(code, id) {
			// Skip non-matching files
			if (!filter_file(id)) {
				return null;
			}

			// Compute content hash
			const hash = await compute_hash(code);
			const existing_hash = hashes.get(id);

			// Check if unchanged
			if (existing_hash === hash) {
				return null;
			}

			// Try cache (if not CI and we have cache dir)
			if (!is_ci && resolved_cache_dir && project_root) {
				const cache_path = await get_file_cache_path(id);
				const cached = await load_cached_extraction(cache_path);

				if (cached?.content_hash === hash) {
					// Cache hit
					const {classes, explicit_classes, diagnostics, elements, css_variables} =
						from_cached_extraction(cached);
					css_classes.add(id, classes, explicit_classes, diagnostics, elements, css_variables);
					hashes.set(id, hash);

					if (virtual_module_loaded) {
						invalidate_virtual_module();
					}
					return null;
				}
			}

			// Extract classes
			const result = extract_css_classes_with_locations(code, {
				filename: id,
				acorn_plugins,
			});

			// Log extraction diagnostics
			if (result.diagnostics) {
				for (const d of result.diagnostics) {
					const loc = `${d.location.file}:${d.location.line}:${d.location.column}`;
					const msg = `[fuz_css] ${loc}: ${d.message}`;
					if (d.level === 'error') {
						log_error(msg);
					} else if (on_warning === 'log') {
						log_warn(msg);
					}
					// 'ignore' and 'throw' (handled at generation time) - don't log here
				}
			}

			// Update CssClasses
			css_classes.add(
				id,
				result.classes,
				result.explicit_classes,
				result.diagnostics,
				result.elements,
				result.css_variables,
			);
			hashes.set(id, hash);

			// Save to cache (fire and forget - don't block transform)
			if (!is_ci && resolved_cache_dir && project_root) {
				get_file_cache_path(id)
					.then((cache_path) =>
						save_cached_extraction(
							cache_path,
							hash,
							result.classes,
							result.explicit_classes,
							result.diagnostics,
							result.elements,
							result.css_variables,
						),
					)
					.catch(() => {
						// Ignore cache errors
					});
			}

			// Trigger HMR if virtual module already loaded
			if (virtual_module_loaded) {
				invalidate_virtual_module();
			}

			return null;
		},

		// Note: handleHotUpdate not needed - transform hook handles file changes,
		// and configureServer's watcher.on('unlink') handles file deletion
	};
};
