/**
 * Vite plugin for fuz_css utility class generation.
 *
 * Uses Vite's transform hook to extract CSS classes from source files
 * as they're processed, including node_modules dependencies.
 * Generates CSS on-demand via virtual module with HMR support.
 *
 * @example
 * ```ts
 * // vite.config.ts
 * import {defineConfig} from 'vite';
 * import jsx from 'acorn-jsx';
 * import {vite_plugin_fuz_css} from '@fuzdev/fuz_css/vite_plugin_fuz_css.js';
 *
 * export default defineConfig({
 *   plugins: [
 *     vite_plugin_fuz_css({
 *       acorn_plugins: [jsx()],
 *     }),
 *   ],
 * });
 * ```
 *
 * @module
 */

import type {Plugin, ViteDevServer} from 'vite';
import {join} from 'node:path';
import {hash_secure} from '@fuzdev/fuz_util/hash.js';

import {extract_css_classes_with_locations} from './css_class_extractor.js';
import {type Diagnostic, CssGenerationError} from './diagnostics.js';
import {generate_classes_css} from './css_class_generation.js';
import {merge_class_definitions} from './css_class_definitions.js';
import {css_class_interpreters} from './css_class_interpreters.js';
import {load_css_properties} from './css_literal.js';
import {
	DEFAULT_CACHE_DIR,
	get_file_cache_path,
	load_cached_extraction,
	save_cached_extraction,
	delete_cached_extraction,
	from_cached_extraction,
} from './css_cache.js';
import {default_cache_operations} from './operations_defaults.js';
import {filter_file_default} from './file_filter.js';
import {CssClasses} from './css_classes.js';
import {
	type StyleRuleIndex,
	load_style_rule_index,
	create_style_rule_index,
	load_default_style_css,
} from './style_rule_parser.js';
import {
	type VariableDependencyGraph,
	build_variable_graph_from_options,
	get_all_variable_names,
} from './variable_graph.js';
import {extract_css_variables} from './css_variable_utils.js';
import {type CssClassVariableIndex, build_class_variable_index} from './class_variable_index.js';
import {resolve_css, generate_bundled_css} from './css_bundled_resolution.js';
import type {CssGeneratorBaseOptions} from './css_plugin_options.js';

/* eslint-disable no-console */

/** Banner comment at the top and bottom of generated CSS output. */
export const FUZ_CSS_BANNER = '/* generated by vite_plugin_fuz_css */';

const VIRTUAL_ID = 'virtual:fuz.css';
// In dev mode, resolve to .js so Vite treats it as JS (for HMR handling)
// In build mode, resolve to .css for proper CSS bundling
const RESOLVED_VIRTUAL_ID_JS = '\0virtual:fuz.css.js';
const RESOLVED_VIRTUAL_ID_CSS = '\0virtual:fuz.css';

// TODO investigate: Dev mode uses a JS wrapper that injects CSS and self-accepts HMR.
// We couldn't get plain CSS with `css-update` to work for virtual modules - there's a
// mismatch between `data-vite-dev-id` (set to `\0virtual:fuz.css`) and the importable
// URL (`/@id/__x00__virtual:fuz.css`). UnoCSS uses `js-update` with `mod.url` for plain
// CSS but that broke all HMR when we tried it. Areas to investigate:
// - How does Vite's CSS HMR actually resolve virtual module URLs?
// - Why does UnoCSS's approach work for them but not here?
// - Is there a way to control what `data-vite-dev-id` gets set to?
// The current JS wrapper approach works reliably, but plain CSS would be cleaner.

/**
 * Skip cache on CI (no point writing cache that won't be reused).
 */
const is_ci = !!process.env.CI;

/**
 * Debounce delay for HMR updates in milliseconds.
 *
 * Short delay to batch rapid file changes (e.g., save-all, rename operations)
 * into a single CSS regeneration. 10ms is enough to catch rapid sequential
 * saves while being imperceptible to users.
 */
const HMR_DEBOUNCE_MS = 10;

/**
 * Options for the fuz_css Vite plugin.
 * Extends the shared base options (no additional Vite-specific options currently needed).
 */
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface VitePluginFuzCssOptions extends CssGeneratorBaseOptions {}

/**
 * Creates the fuz_css Vite plugin.
 *
 * Extracts CSS classes from source files during Vite's transform phase
 * and generates optimized CSS via the `virtual:fuz.css` virtual module.
 */
export const vite_plugin_fuz_css = (options: VitePluginFuzCssOptions = {}): Plugin => {
	const {
		filter_file = filter_file_default,
		class_definitions: user_class_definitions,
		include_default_classes = true,
		class_interpreters = css_class_interpreters,
		additional_classes,
		exclude_classes,
		acorn_plugins,
		on_error = is_ci ? 'throw' : 'log',
		on_warning = 'log',
		cache_dir = DEFAULT_CACHE_DIR,
		base_css,
		variables,
		theme_specificity = 1,
		additional_elements,
		additional_variables,
		exclude_elements,
		exclude_variables,
		ops = default_cache_operations,
	} = options;

	// Derive include flags from null check
	const include_base = base_css !== null;
	const include_theme = variables !== null;

	// Merge class definitions (validates that definitions exist when needed)
	const all_class_definitions = merge_class_definitions(
		user_class_definitions,
		include_default_classes,
	);

	// Convert to Sets for efficient lookup
	const include_set = additional_classes ? new Set(additional_classes) : null;
	const exclude_set = exclude_classes ? new Set(exclude_classes) : null;

	// Plugin state
	const css_classes = new CssClasses(include_set, exclude_set);
	const hashes: Map<string, string> = new Map();
	/** CSS variables detected per file via simple regex scan (filtered against theme) */
	const detected_variables_by_file: Map<string, Set<string>> = new Map();
	let virtual_module_loaded = false;
	let server: ViteDevServer | null = null;
	let css_properties: Set<string> | null = null;
	let resolved_cache_dir: string | null = null;
	let project_root: string | null = null;
	let hmr_timeout: ReturnType<typeof setTimeout> | null = null;
	let last_generated_css: string | null = null;
	let pending_css: string | null = null; // CSS generated during HMR, reused by load()

	/**
	 * Updates detected CSS variables for a file via regex scan against theme variables.
	 * Variables not in the theme are silently ignored (may be user-defined).
	 */
	const update_detected_variables = (id: string, code: string): void => {
		if (!variable_graph) return;
		const theme_var_names = get_all_variable_names(variable_graph);
		const file_vars: Set<string> = new Set();
		for (const name of extract_css_variables(code)) {
			if (theme_var_names.has(name)) {
				file_vars.add(name);
			}
		}
		if (file_vars.size > 0) {
			detected_variables_by_file.set(id, file_vars);
		} else {
			detected_variables_by_file.delete(id);
		}
	};

	// Bundled CSS resources (loaded lazily on first CSS generation when bundled mode is enabled)
	let style_rule_index: StyleRuleIndex | null = null;
	let variable_graph: VariableDependencyGraph | null = null;
	let class_variable_index: CssClassVariableIndex | null = null;

	// Promise for in-flight resource loading (prevents duplicate loads)
	let bundled_resources_promise: Promise<void> | null = null;

	/** Ensures bundled CSS resources are loaded. Safe to call multiple times. */
	const ensure_bundled_resources = async (): Promise<void> => {
		if (style_rule_index !== null) return; // Already loaded
		if (bundled_resources_promise) {
			await bundled_resources_promise; // Wait for in-flight loading
			return;
		}
		bundled_resources_promise = (async () => {
			// Load style rule index based on base_css option
			if (typeof base_css === 'string') {
				// Custom CSS string (replacement)
				style_rule_index = await create_style_rule_index(base_css);
			} else if (typeof base_css === 'function') {
				// Callback to modify default CSS
				const default_css = await load_default_style_css(ops);
				const modified_css = base_css(default_css);
				style_rule_index = await create_style_rule_index(modified_css);
			} else {
				// Use default style.css (undefined or null)
				style_rule_index = await load_style_rule_index(ops);
			}

			// Build variable graph based on variables option
			variable_graph = build_variable_graph_from_options(variables);

			class_variable_index = build_class_variable_index(all_class_definitions);
		})();
		await bundled_resources_promise;
	};

	/** Logs a warning message (works in both dev and build) */
	const log_warn = (msg: string): void => {
		if (server) {
			server.config.logger.warn(msg);
		} else {
			console.warn(msg);
		}
	};

	/** Logs an error message (works in both dev and build) */
	const log_error = (msg: string): void => {
		if (server) {
			server.config.logger.error(msg);
		} else {
			console.error(msg);
		}
	};

	/**
	 * Generates CSS from the current classes.
	 */
	const generate_css = (): string => {
		const {
			all_classes: classes,
			all_classes_with_locations: locations,
			explicit_classes,
			all_elements,
			explicit_elements,
			explicit_variables,
		} = css_classes.get_all();

		const utility_result = generate_classes_css({
			class_names: classes,
			class_definitions: all_class_definitions,
			interpreters: class_interpreters,
			css_properties,
			class_locations: locations,
			explicit_classes,
		});

		// Collect all diagnostics: extraction + generation
		const all_diagnostics: Array<Diagnostic> = [
			...css_classes.get_diagnostics(),
			...utility_result.diagnostics,
		];

		// Generate bundled CSS if base or theme are enabled and resources are loaded
		let final_css: string;
		if (
			(include_base || include_theme) &&
			style_rule_index &&
			variable_graph &&
			class_variable_index
		) {
			// Aggregate detected CSS variables from all files
			const detected_css_variables: Set<string> = new Set();
			for (const vars of detected_variables_by_file.values()) {
				for (const v of vars) {
					detected_css_variables.add(v);
				}
			}

			// Add explicit variables from @fuz-variables comments to detected set for inclusion,
			// and pass as explicit_variables to resolve_css for error reporting on typos
			if (explicit_variables) {
				for (const v of explicit_variables) {
					detected_css_variables.add(v);
				}
			}

			const resolution = resolve_css({
				style_rule_index,
				variable_graph,
				class_variable_index,
				detected_elements: all_elements,
				detected_classes: classes,
				detected_css_variables,
				utility_variables_used: utility_result.variables_used,
				additional_elements,
				additional_variables,
				theme_specificity,
				exclude_elements,
				exclude_variables,
				explicit_elements,
				explicit_variables,
			});

			// Add resolution diagnostics
			all_diagnostics.push(...resolution.diagnostics);

			final_css = generate_bundled_css(resolution, utility_result.css, {
				include_theme,
				include_base,
				include_utilities: true,
			});
		} else {
			// utility-only mode (legacy behavior or resources not loaded yet)
			final_css = utility_result.css;
		}

		// Separate errors and warnings
		const errors = all_diagnostics.filter((d) => d.level === 'error');
		const warnings = all_diagnostics.filter((d) => d.level === 'warning');

		// Handle warnings based on on_warning setting
		if (warnings.length > 0) {
			if (on_warning === 'throw') {
				throw new CssGenerationError(warnings);
			} else if (on_warning === 'log') {
				for (const d of utility_result.diagnostics.filter((d) => d.level === 'warning')) {
					log_warn(`[fuz_css] ${d.class_name}: ${d.message}`);
				}
			}
			// 'ignore' - do nothing
		}

		// Handle errors based on on_error setting
		if (errors.length > 0) {
			if (on_error === 'throw') {
				throw new CssGenerationError(errors);
			}
			// Log errors (extraction diagnostics already logged in transform)
			for (const d of utility_result.diagnostics.filter((d) => d.level === 'error')) {
				log_error(`[fuz_css] ${d.class_name}: ${d.message}`);
			}
		}

		return `${FUZ_CSS_BANNER}\n\n${final_css}\n\n${FUZ_CSS_BANNER}`;
	};

	/**
	 * Invalidates the virtual module and triggers HMR.
	 * Debounced to avoid spamming updates when multiple files change rapidly.
	 * Only triggers if the generated CSS actually changed.
	 */
	const invalidate_virtual_module = (): void => {
		if (!server) return;

		// Skip HMR if bundled resources aren't loaded yet
		// (will be loaded on first load() call, CSS regenerated then)
		if ((include_base || include_theme) && style_rule_index === null) {
			return;
		}

		if (hmr_timeout) {
			clearTimeout(hmr_timeout);
		}
		hmr_timeout = setTimeout(() => {
			hmr_timeout = null;

			// Check if CSS actually changed
			const new_css = generate_css();
			if (new_css === last_generated_css) {
				return; // No change, skip HMR
			}
			last_generated_css = new_css;
			pending_css = new_css; // Store for reuse in load() to avoid regenerating

			const mod = server!.moduleGraph.getModuleById(RESOLVED_VIRTUAL_ID_JS);
			if (mod) {
				server!.moduleGraph.invalidateModule(mod);
				// TODO investigate: This hardcoded path matches Vite's URL encoding for virtual
				// modules. Using `mod.url` doesn't work (it's `\0virtual:fuz.css.js`). Could break
				// if Vite changes their encoding scheme. Is there a proper API for this?
				const hmr_path = '/@id/__x00__virtual:fuz.css.js';
				const hot = server?.hot ?? server!.ws;
				hot.send({
					type: 'update',
					updates: [
						{
							type: 'js-update',
							path: hmr_path,
							acceptedPath: hmr_path,
							timestamp: Date.now(),
						},
					],
				});
			}
		}, HMR_DEBOUNCE_MS);
	};

	return {
		name: 'vite-plugin-fuz-css',
		// Run before other plugins (like Svelte) to see original source files
		enforce: 'pre',

		configResolved(resolved_config) {
			const root = resolved_config.root;
			project_root = root.endsWith('/') ? root : root + '/';
			resolved_cache_dir = join(root, cache_dir);
		},

		configureServer(dev_server) {
			server = dev_server;

			// Handle file deletion - watcher 'unlink' event
			dev_server.watcher.on('unlink', (file) => {
				if (hashes.has(file)) {
					css_classes.delete(file);
					hashes.delete(file);
					detected_variables_by_file.delete(file);

					// Delete cache file (fire and forget)
					if (!is_ci && resolved_cache_dir && project_root) {
						const cache_path = get_file_cache_path(file, resolved_cache_dir, project_root);
						delete_cached_extraction(ops, cache_path).catch(() => {
							// Ignore cache deletion errors
						});
					}

					if (virtual_module_loaded) {
						invalidate_virtual_module();
					}
				}
			});

			// Clean up pending timeout on server close
			dev_server.httpServer?.on('close', () => {
				if (hmr_timeout) {
					clearTimeout(hmr_timeout);
					hmr_timeout = null;
				}
			});
		},

		async buildStart() {
			// Load CSS properties for validation (needed for transform())
			css_properties = await load_css_properties();
			// Note: Bundled CSS resources (style_rule_index, variable_graph, class_variable_index)
			// are loaded lazily on first load() call via ensure_bundled_resources()
		},

		resolveId(id) {
			if (id === VIRTUAL_ID) {
				// In dev mode, resolve to .js for HMR support
				// In build mode, resolve to .css for proper bundling
				return server ? RESOLVED_VIRTUAL_ID_JS : RESOLVED_VIRTUAL_ID_CSS;
			}
			return undefined;
		},

		async load(id) {
			// Dev mode: JS module that injects CSS and handles HMR
			if (id === RESOLVED_VIRTUAL_ID_JS) {
				virtual_module_loaded = true;
				// Defer resource loading to first virtual module access
				if (include_base || include_theme) {
					await ensure_bundled_resources();
				}
				// Use pending CSS from HMR if available, avoiding redundant generation
				const css = pending_css ?? generate_css();
				pending_css = null;
				last_generated_css = css; // Track for HMR diffing
				const escaped_css = JSON.stringify(css);
				return `
const css = ${escaped_css};

// Find existing style tag or create new one
let style = document.querySelector('style[data-fuz-css]');
if (!style) {
  style = document.createElement('style');
  style.setAttribute('data-fuz-css', '');
  document.head.appendChild(style);
}
style.textContent = css;

if (import.meta.hot) {
  import.meta.hot.accept();
}

export {};
`;
			}
			// Build mode: plain CSS
			if (id === RESOLVED_VIRTUAL_ID_CSS) {
				virtual_module_loaded = true;
				// Defer resource loading to first virtual module access
				if (include_base || include_theme) {
					await ensure_bundled_resources();
				}
				// Return empty CSS for build - generateBundle will append the complete CSS
				return '/* fuz_css placeholder */';
			}
			return undefined;
		},

		generateBundle(_options, bundle) {
			// Regenerate CSS with all extracted classes and append to the CSS asset
			// This runs after all transforms are complete, so all classes are available
			const generated_css = generate_css();

			// Find the main CSS asset and append our generated CSS
			// Vite combines all CSS into one or more asset files
			for (const chunk of Object.values(bundle)) {
				if (
					chunk.type === 'asset' &&
					typeof chunk.source === 'string' &&
					chunk.fileName.endsWith('.css')
				) {
					// Append the complete generated CSS to the end
					chunk.source = chunk.source + '\n' + generated_css;
					break; // Only append to first CSS asset
				}
			}
		},

		async transform(code, id) {
			// Skip non-matching files
			if (!filter_file(id)) {
				return null;
			}

			// Compute content hash
			const hash = await hash_secure(code);
			const existing_hash = hashes.get(id);

			// Check if unchanged
			if (existing_hash === hash) {
				return null;
			}

			// Try cache (if not CI and we have cache dir)
			if (!is_ci && resolved_cache_dir && project_root) {
				const cache_path = get_file_cache_path(id, resolved_cache_dir, project_root);
				const cached = await load_cached_extraction(ops, cache_path);

				if (cached?.content_hash === hash) {
					// Cache hit
					const {
						classes,
						explicit_classes,
						diagnostics,
						elements,
						explicit_elements,
						explicit_variables: cached_explicit_variables,
					} = from_cached_extraction(cached);
					css_classes.add(
						id,
						classes,
						explicit_classes,
						diagnostics,
						elements,
						explicit_elements,
						cached_explicit_variables,
					);
					update_detected_variables(id, code);
					hashes.set(id, hash);

					if (virtual_module_loaded) {
						invalidate_virtual_module();
					}
					return null;
				}
			}

			// Extract classes
			const result = extract_css_classes_with_locations(code, {
				filename: id,
				acorn_plugins,
			});

			// Log extraction diagnostics
			if (result.diagnostics) {
				for (const d of result.diagnostics) {
					const loc = `${d.location.file}:${d.location.line}:${d.location.column}`;
					const msg = `[fuz_css] ${loc}: ${d.message}`;
					if (d.level === 'error') {
						log_error(msg);
					} else if (on_warning === 'log') {
						log_warn(msg);
					}
					// 'ignore' and 'throw' (handled at generation time) - don't log here
				}
			}

			// Update CssClasses
			css_classes.add(
				id,
				result.classes,
				result.explicit_classes,
				result.diagnostics,
				result.elements,
				result.explicit_elements,
				result.explicit_variables,
			);
			update_detected_variables(id, code);
			hashes.set(id, hash);

			// Save to cache (fire and forget - don't block transform)
			if (!is_ci && resolved_cache_dir && project_root) {
				const cache_path = get_file_cache_path(id, resolved_cache_dir, project_root);
				save_cached_extraction(
					ops,
					cache_path,
					hash,
					result.classes,
					result.explicit_classes,
					result.diagnostics,
					result.elements,
					result.explicit_elements,
					result.explicit_variables,
				).catch(() => {
					// Ignore cache errors
				});
			}

			// Trigger HMR if virtual module already loaded
			if (virtual_module_loaded) {
				invalidate_virtual_module();
			}

			return null;
		},

		// Note: handleHotUpdate not needed - transform hook handles file changes,
		// and configureServer's watcher.on('unlink') handles file deletion
	};
};
